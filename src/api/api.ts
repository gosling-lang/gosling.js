import * as PIXI from 'pixi.js';
import type { TrackApiData, VisUnitApiData, ViewApiData } from '@gosling-lang/gosling-schema';
import { subscribe, unsubscribe } from './pubsub';
import { computeChromSizes, GenomicPositionHelper } from '../core/utils/assembly';
import { type CompleteThemeDeep } from '../core/utils/theme';
import type { IdTable } from './track-and-view-ids';
import type { renderGosling } from 'demo/gosling-component';
import type { Plot } from '../tracks/utils';

// TODO: Complete the API
export type HiGlassApi = {
    api: Record<string, any>;
    pixiRenderer: PIXI.Renderer;
    pixiStage: PIXI.IRenderableObject;
};

/**
 * Information of suggested genes.
 */
interface GeneSuggestion {
    geneName: string; // gene symbol
    score: number; // higher score means suggested gene is more likely to match the searched keyword
    chr: string; // chromosome name
    txStart: number; // absolute genomic position assuming chromosomes are concat end-to-end
    txEnd: number; // absolute genomic position assuming chromosomes are concat end-to-end
}

export interface GoslingApi {
    subscribe: typeof subscribe;
    unsubscribe: typeof unsubscribe;
    zoomTo(viewId: string, position: string, padding?: number, duration?: number): void;
    zoomToExtent(viewId: string, duration?: number): void;
    zoomToGene(viewId: string, gene: string, padding?: number, duration?: number): void;
    suggestGene(viewId: string, keyword: string, callback: (suggestions: GeneSuggestion[]) => void): void;
    getTracksAndViews(): VisUnitApiData[];
    /**
     * Get an array of all available track IDs that are either specified by users or auto-generated by the compiler.
     * This can be used to call other API functions, e.g., `getTrack('track-1')`.
     */
    getTrackIds(): string[];
    getTracks(): TrackApiData[];
    getTrack(trackId: string): TrackApiData | undefined;
    getViews(): ViewApiData[];
    getView(viewId: string): ViewApiData | undefined;
    exportPng(transparentBackground?: boolean): void;
    exportPdf(transparentBackground?: boolean): void;
    getCanvas(options?: { resolution?: number; transparentBackground?: boolean }): {
        canvas: HTMLCanvasElement;
        canvasWidth: number;
        canvasHeight: number;
        resolution: number;
    };
}

export function createEmptyApi(): GoslingApi {
    return {
        subscribe,
        unsubscribe,
        zoomTo: () => { },
        zoomToExtent: () => { },
        zoomToGene: () => { },
        suggestGene: () => { },
        getTracksAndViews: () => [],
        getTrackIds: () => [],
        getTracks: () => [],
        getTrack: () => {
            return undefined;
        },
        getViews: () => [],
        getView: () => {
            return undefined;
        },
        exportPng: () => { },
        exportPdf: () => { },
        getCanvas: () => {
            return {
                canvas: new HTMLCanvasElement(),
                canvasWidth: 0,
                canvasHeight: 0,
                resolution: 0
            };
        }
    };
}
// TODO: After fully implementing this, remove `Pick` from the return type
export function createApiV2(
    compileResult?: ReturnType<typeof renderGosling>
): Pick<
    GoslingApi,
    | 'getTracksAndViews'
    | 'getTracks'
    | 'getTrackIds'
    | 'getTrack'
    | 'getViews'
    | 'getView'
    | 'getCanvas'
    | 'subscribe'
    | 'unsubscribe'
    | 'exportPdf'
    | 'exportPng'
    | 'zoomTo'
> {
    if (!compileResult) {
        return createEmptyApi();
    }

    const { tracksAndViews, theme, pixiManager, plots } = compileResult;
    const getTracksAndViews = () => {
        return [...tracksAndViews];
    };
    const getTracks = () => {
        return [...getTracksAndViews().filter(d => d.type === 'track')] as TrackApiData[];
    };
    const getTrackIds = () => {
        return getTracks().map(d => d.id);
    };
    const getTrack = (trackId: string) => {
        const trackInfoFound = getTracks().find(d => d.id === trackId);
        if (!trackInfoFound) {
            console.warn(`[getTrack()] Unable to find a track using the ID (${trackId})`);
        }
        return trackInfoFound;
    };
    const getViews = () => {
        return [...getTracksAndViews().filter(d => d.type === 'view')] as ViewApiData[];
    };
    const getView = (viewId: string) => {
        const view = getViews().find(d => d.id === viewId);
        if (!view) {
            console.warn(`Unable to find a view with the ID of ${viewId}`);
        }
        return view;
    };
    const getCanvas: GoslingApi['getCanvas'] = options => {
        const resolution = options?.resolution ?? 4;
        const transparentBackground = options?.transparentBackground ?? false;

        const renderer = pixiManager.app.renderer;
        const renderTexture = PIXI.RenderTexture.create({
            width: renderer.width / 2,
            height: renderer.height / 2,
            resolution
        });

        renderer.render(pixiManager.app.stage, { renderTexture: renderTexture });

        const canvas = renderer.plugins.extract.canvas(renderTexture);

        // Set background color for the given theme in the gosling spec
        // Otherwise, it is transparent
        const canvasWithBg = document.createElement('canvas') as HTMLCanvasElement;
        canvasWithBg.width = canvas.width;
        canvasWithBg.height = canvas.height;

        const ctx = canvasWithBg.getContext('2d')!;
        if (!transparentBackground) {
            ctx.fillStyle = theme.root.background;
            ctx.fillRect(0, 0, canvasWithBg.width, canvasWithBg.height);
        }
        ctx.drawImage(canvas, 0, 0);

        return {
            canvas: canvasWithBg,
            resolution,
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
        };
    };
    const exportPng: GoslingApi['exportPng'] = transparentBackground => {
        const { canvas } = getCanvas({ resolution: 4, transparentBackground });
        canvas.toBlob(blob => {
            const a = document.createElement('a');
            document.body.append(a);
            a.download = 'gosling-visualization';
            a.href = URL.createObjectURL(blob!);
            a.click();
            a.remove();
        }, 'image/png');
    };
    const exportPdf: GoslingApi['exportPdf'] = async transparentBackground => {
        const { jsPDF } = await import('jspdf');
        const { canvas } = getCanvas({ resolution: 4, transparentBackground });
        const imgData = canvas.toDataURL('image/jpeg', 1);
        const pdf = new jsPDF({
            orientation: canvas.width < canvas.height ? 'p' : 'l',
            unit: 'pt',
            format: [canvas.width, canvas.height]
        });
        pdf.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);
        pdf.save('gosling-visualization.pdf');
    };

    const zoomTo: GoslingApi['zoomTo'] = (trackId, position, padding = 0, duration = 1000) => {
        // Get the plot and track instances using the track ID
        const plot = (plots as Record<string, unknown>)[trackId] as Plot;
        const track = getTrack(trackId);

        if (!plot || !track) {
            console.warn(`[zoomTo()] Unable to find track for ID (${trackId})`);
            return;
        }

        // Parse the genomic position (e.g., "chr1:100-1000" or "chr1")
        const assembly = track.spec.assembly;
        const manager = GenomicPositionHelper.fromString(position);
        const absCoordinates = manager.toAbsoluteCoordinates(assembly, padding);

        // Get current domain and set up the target domain
        const xDomainFrom = plot.xDomain.value;
        const xDomainTo: [number, number] = [absCoordinates[0], absCoordinates[1]];

        // If duration is 0, immediately set the domain
        if (duration === 0) {
            plot.xDomain.value = xDomainTo;
            return;
        }

        // Use requestAnimationFrame for smooth animation
        const startTime = performance.now();

        // Simple linear interpolation function
        const lerp = (start: number, end: number, t: number) => start + (end - start) * t;

        // Ease-in-out cubic easing function
        const easeInOutCubic = (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);

        const animate = (currentTime: number) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeInOutCubic(progress);

            // Interpolate the domain values
            const newStart = lerp(xDomainFrom[0], xDomainTo[0], easedProgress);
            const newEnd = lerp(xDomainFrom[1], xDomainTo[1], easedProgress);

            plot.xDomain.value = [newStart, newEnd];

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Ensure the final domain is set precisely
                plot.xDomain.value = xDomainTo;
            }
        };

        requestAnimationFrame(animate);
    };

    return {
        subscribe,
        unsubscribe,
        getTrackIds,
        getTracksAndViews,
        getTracks,
        getTrack,
        getView,
        getViews,
        getCanvas,
        exportPng,
        exportPdf,
        zoomTo
    };
}

export function createApi(
    hg: Readonly<HiGlassApi>,
    tracksAndViews: readonly VisUnitApiData[],
    theme: Required<CompleteThemeDeep>,
    idTable: Readonly<IdTable>
): GoslingApi {
    const idTableCopy = structuredClone(idTable);
    /**
     * Get the HiGlass view ID from the Gosling track ID.
     */
    const getHgViewId = (trackId: string) => {
        const viewId = idTableCopy[trackId];
        if (!viewId) {
            console.warn(`Unable to find the track ID, named ${trackId}.`);
        }
        return viewId ?? trackId;
    };
    const getTrackIds = () => {
        return Object.keys(idTableCopy);
    };
    const getTracksAndViews = () => {
        return [...tracksAndViews];
    };
    const getTracks = () => {
        return [...getTracksAndViews().filter(d => d.type === 'track')] as TrackApiData[];
    };
    const getTrack = (trackId: string) => {
        const trackInfoFound = getTracks().find(d => d.id === trackId);
        if (!trackInfoFound) {
            console.warn(`[getTrack()] Unable to find a track using the ID (${trackId})`);
        }
        return trackInfoFound;
    };
    const getViews = () => {
        return [...getTracksAndViews().filter(d => d.type === 'view')] as ViewApiData[];
    };
    const getView = (viewId: string) => {
        const view = getViews().find(d => d.id === viewId);
        if (!view) {
            console.warn(`Unable to find a view with the ID of ${viewId}`);
        }
        return view;
    };
    const getCanvas: GoslingApi['getCanvas'] = options => {
        const resolution = options?.resolution ?? 4;
        const transparentBackground = options?.transparentBackground ?? false;

        const renderer = hg.pixiRenderer;
        const renderTexture = PIXI.RenderTexture.create({
            width: renderer.width / 2,
            height: renderer.height / 2,
            resolution
        });

        renderer.render(hg.pixiStage, { renderTexture: renderTexture });

        const canvas = renderer.plugins.extract.canvas(renderTexture);

        // Set background color for the given theme in the gosling spec
        // Otherwise, it is transparent
        const canvasWithBg = document.createElement('canvas') as HTMLCanvasElement;
        canvasWithBg.width = canvas.width;
        canvasWithBg.height = canvas.height;

        const ctx = canvasWithBg.getContext('2d')!;
        if (!transparentBackground) {
            ctx.fillStyle = theme.root.background;
            ctx.fillRect(0, 0, canvasWithBg.width, canvasWithBg.height);
        }
        ctx.drawImage(canvas, 0, 0);

        return {
            canvas: canvasWithBg,
            resolution,
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
        };
    };
    return {
        subscribe,
        unsubscribe,
        zoomTo: (trackId, position, padding = 0, duration = 1000) => {
            // Accepted input: 'chr1' or 'chr1:1-1000'
            const assembly = getTrack(trackId)?.spec.assembly;
            const manager = GenomicPositionHelper.fromString(position);
            const absCoordinates = manager.toAbsoluteCoordinates(assembly, padding);
            const hgViewId = getHgViewId(trackId);
            hg.api.zoomTo(hgViewId, ...absCoordinates, ...absCoordinates, duration);
        },
        zoomToExtent: (trackId, duration = 1000) => {
            const assembly = getTrack(trackId)?.spec.assembly;
            const [start, end] = [0, computeChromSizes(assembly).total];
            const hgViewId = getHgViewId(trackId);
            hg.api.zoomTo(hgViewId, start, end, start, end, duration);
        },
        zoomToGene: (trackId, gene, padding = 0, duration = 1000) => {
            const hgViewId = getHgViewId(trackId);
            hg.api.zoomToGene(hgViewId, gene, padding, duration);
        },
        suggestGene: (trackId: string, keyword: string, callback: (suggestions: GeneSuggestion[]) => void) => {
            const hgViewId = getHgViewId(trackId);
            hg.api.suggestGene(hgViewId, keyword, callback);
        },
        getTrackIds,
        getTracksAndViews,
        getTracks,
        getTrack,
        getView,
        getViews,
        getCanvas,
        exportPng: transparentBackground => {
            const { canvas } = getCanvas({ resolution: 4, transparentBackground });
            canvas.toBlob(blob => {
                const a = document.createElement('a');
                document.body.append(a);
                a.download = 'gosling-visualization';
                a.href = URL.createObjectURL(blob!);
                a.click();
                a.remove();
            }, 'image/png');
        },
        exportPdf: async transparentBackground => {
            const { jsPDF } = await import('jspdf');
            const { canvas } = getCanvas({ resolution: 4, transparentBackground });
            const imgData = canvas.toDataURL('image/jpeg', 1);
            const pdf = new jsPDF({
                orientation: canvas.width < canvas.height ? 'p' : 'l',
                unit: 'pt',
                format: [canvas.width, canvas.height]
            });
            pdf.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);
            pdf.save('gosling-visualization.pdf');
        }
    };
}
