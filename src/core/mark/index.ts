import { GoslingTrackModel } from '../gosling-track-model';
import { drawPoint } from './point';
import { drawLine } from './line';
import { drawBar } from './bar';
import { drawArea } from './area';
import { drawRect } from './rect';
import { ChannelTypes } from '../gosling.schema';
import { drawTriangle } from './triangle';
import { drawText } from './text';
import { drawRule } from './rule';
import { drawLink } from './link';
import { drawGrid } from './grid';
import { drawChartOutlines } from './outline';
import { drawColorLegend, drawRowLegend } from './legend';
import { drawCircularYAxis, drawLinearYAxis } from './axis';
import { drawCircularOutlines } from './outline-circular';
import { drawBackground } from './background';
import { Theme } from '../utils/theme';
import colorToHex from '../utils/color-to-hex';
import { scaleLinear } from 'd3-scale';
import Logging from '../utils/log'

/**
 * Visual channels currently supported for visual encoding.
 */
export const SUPPORTED_CHANNELS: (keyof typeof ChannelTypes)[] = [
    'x',
    'xe',
    'x1',
    'x1e',

    'y',
    'ye',
    'y1',
    'y1e',

    'color',
    'size',
    'row',
    'stroke',
    'strokeWidth',
    'opacity',
    'text'
    // ...
];

export const RESOLUTION = 4;

/**
 * Draw a track based on the track specification in a Gosling grammar.
 */
export function drawMark(HGC: any, trackInfo: any, tile: any, model: GoslingTrackModel, theme: Theme = 'light', domain: any, range: any) {
    // console.log('drawMark()');
    if (!HGC || !trackInfo || !tile) {
        // We did not receive parameters correctly.
        return;
    }

    if (model.spec().mark === 'brush') {
        // We do not draw brush. Instead, higlass do.
        return;
    }

    const CIRCULAR = model.spec().layout === 'circular';

    // Replace the scale of a genomic axis with the one that is generated by the HiGlass data fetcher.
    ['x', 'x1', 'x1e', 'xe'].forEach((d: any) => {
        // const c = tm.spec()[d as keyof typeof ChannelTypes];
        // if(IsChannelDeep(c) && c.type === 'genomic') {
        model.setChannelScale(
            d, 
            // trackInfo._xScale
            HGC.libraries.d3Scale
                .scaleLinear()
                .domain(domain)
                .range(range)
        );
        // }
    });

    /* Embellishment before rendering plots */
    // drawBackground(HGC, trackInfo, tile, model);
    // if (CIRCULAR) {
    //     drawCircularOutlines(HGC, trackInfo, tile, model);
    // } else {
    //     drawChartOutlines(HGC, trackInfo, model, theme);
    // }
    // drawGrid(trackInfo, model, theme);

    // DEBUG
    // drawChartOutlines(HGC, trackInfo, model);
    //

    /* spec */
    switch (model.spec().mark) {
        case 'point':
            drawPoint(trackInfo, tile.graphics, model);
            break;
        case 'bar':
            drawBar(trackInfo, tile, model);
            break;
        case 'line':
            drawLine(tile.graphics, model);
            break;
        case 'area':
            drawArea(HGC, trackInfo, tile, model);
            break;
        case 'rect':
            if (model.spec().layout === 'circular') {
                drawRect(HGC, trackInfo, tile, model);
            } else {
                const tileSize = trackInfo.tilesetInfo.tile_size;
                const { tileX, tileWidth } = trackInfo.getTilePosAndDimensions(
                    tile.gos.zoomLevel,
                    tile.gos.tilePos,
                    tileSize
                );
                const [trackWidth, trackHeight] = trackInfo.dimensions;
                const xDomain = domain;
                const xRange = range;
                // const xDomain = trackInfo._xScale.domain();
                // const xRange = trackInfo._xScale.range();

                // trackInfo.setUpShaderAndTextures();
                // Logging.recordTime('worker');
                trackInfo.worker.then((tileFunctions: any) => {
                    // Logging.printTime('worker');
                    tileFunctions
                        .rectProperties(
                            model.spec(),
                            model.data(),
                            trackWidth,
                            trackHeight,
                            tileSize,
                            xDomain,
                            xRange,
                            tileX,
                            tileWidth
                        )
                        .then((props: any) => {
                            // Logging.printTime('worker');
                            const textures: { [color: number]: PIXI.Texture } = {};
                            const getTexture = (color: number) => {
                                if (textures[color]) {
                                    return textures[color];
                                } else {
                                    const g = new PIXI.Graphics();
                                    g.beginFill(color);
                                    g.drawRect(0, 0, 1, 1);
                                    g.endFill();
                                    textures[color] = HGC.services.pixiRenderer.generateTexture(g);
                                    return;
                                }
                            };
                            const tabularData = JSON.parse(Buffer.from(props).toString());
                            const g = new HGC.libraries.PIXI.Graphics();
                            // console.log(tabularData.slice(0, 1));
                            // trackInfo.errorTextText = null;
                            trackInfo.pBorder.clear();
                            // trackInfo.drawError();
                            trackInfo.forceDraw();

                            // trackInfo.setUpShaderAndTextures(trackInfo, HGC);

                            const positions = new Float32Array(tabularData.positions);
                            const colors = new Float32Array(tabularData.colorIdx);
                            const ixs = new Int32Array(tabularData.ixs);

                            console.log('this.positions', positions, colors, ixs);

                            const newGraphics = new HGC.libraries.PIXI.Graphics();
                            
                            const geometry = new HGC.libraries.PIXI.Geometry().addAttribute(
                                'position',
                                positions,
                                2
                            ); // x,y
                            geometry.addAttribute('aColorIdx', colors, 1);
                            geometry.addIndex(ixs);

                            if (positions.length) {
                                const state = new HGC.libraries.PIXI.State();
                                const mesh = new HGC.libraries.PIXI.Mesh(geometry, trackInfo.shader, state);

                                newGraphics.addChild(mesh);
                            }
                            trackInfo.pMain.x = trackInfo.position[0];

                            // console.log('trackInfo.pMain.x', trackInfo.pMain.x);

                            if (trackInfo.segmentGraphics) {
                                trackInfo.pMain.removeChild(trackInfo.segmentGraphics);
                            }

                            trackInfo.pMain.addChild(newGraphics);
                            trackInfo.segmentGraphics = newGraphics;

                            trackInfo.drawnAtScale = HGC.libraries.d3Scale
                            .scaleLinear().domain(xDomain).range(xRange);
                            console.log('diff', trackInfo._xScale.range(), xRange);

                            // console.log('render.scaleScalableGraphics');
                            trackInfo.scaleScalableGraphics(
                                trackInfo.segmentGraphics,
                                trackInfo._xScale,
                                trackInfo.drawnAtScale
                            );

                            // trackInfo.segmentGraphics.scale.y = trackInfo.valueScaleTransform.k;
                            // trackInfo.segmentGraphics.position.y = trackInfo.valueScaleTransform.y;

                            // trackInfo.draw();
                            trackInfo.forceDraw();

                            // tabularData.forEach((d: any) => {
                            // const colorHex = colorToHex(d.color === 'none' ? 'white' : d.color);
                            // const s = new PIXI.Sprite(getTexture(colorHex));

                            // const s = new PIXI.Graphics();
                            // s.beginFill(colorToHex(d.color === 'none' ? 'white' : d.color), d.color === 'none' ? 0 : d.opacity);
                            // s.drawRect(d.xs, d.ys, d.xe - d.xs, (d.ye - d.ys));
                            //Change the sprite's position
                            // s.x = d.xs;
                            // s.y = d.ys;

                            // s.width = d.xe - d.xs;
                            // s.height = (d.ye - d.ys);

                            // g.addChild(s);
                            // });
                            // tile.graphics.clear();
                            // tile.graphics.removeChildren();
                            // tile.graphics.addChild(g);

                            // const entireSprite = new PIXI.Sprite(HGC.services.pixiRenderer.generateTexture(g, PIXI.SCALE_MODES.LINEAR, 14));
                            // tile.graphics.addChild(entireSprite);

                            // entireSprite.x = tileX;
                            // entireSprite.y = 0;
                            // entireSprite.height = trackHeight;
                            // entireSprite.width = tileWidth;
                        });
                });
            }
            break;
        case 'triangleLeft':
        case 'triangleRight':
        case 'triangleBottom':
            drawTriangle(tile.graphics, model);
            break;
        case 'text':
            drawText(HGC, trackInfo, tile, model);
            break;
        case 'rule':
            drawRule(HGC, trackInfo, tile, model);
            break;
        case 'link':
            drawLink(tile.graphics, model);
            break;
        default:
            console.warn('Unsupported mark type');
            break;
    }

    /* embellishment after rendering plots */
    // if (CIRCULAR) {
    //     drawCircularYAxis(HGC, trackInfo, tile, model, theme);
    // } else {
    //     drawLinearYAxis(HGC, trackInfo, tile, model, theme);
    //     drawRowLegend(HGC, trackInfo, tile, model, theme);
    // }
    // drawColorLegend(HGC, trackInfo, tile, model, theme);
}
